[2025-09-12] Source URL: https://developers.google.com/workspace/calendar/api/guides/sync

이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.
Switch to English
홈 [https://developers.google.com/?hl=ko]
Google Workspace [https://developers.google.com/workspace?hl=ko]
Google Calendar [https://developers.google.com/workspace/calendar?hl=ko]
가이드 [https://developers.google.com/workspace/calendar/api/guides/overview?hl=ko]
의견 보내기
효율적인 리소스 동기화
bookmark_border
이 페이지의 내용
개요 [https://developers.google.com/workspace/calendar/api/guides/sync?hl=ko#overview]
초기 전체 동기화 [https://developers.google.com/workspace/calendar/api/guides/sync?hl=ko#initial_full_sync]
증분 동기화 [https://developers.google.com/workspace/calendar/api/guides/sync?hl=ko#incremental_sync]
서버에서 전체 동기화 필요 [https://developers.google.com/workspace/calendar/api/guides/sync?hl=ko#full_sync_required_by_server]
샘플 코드 [https://developers.google.com/workspace/calendar/api/guides/sync?hl=ko#sample_code]
기존 동기화 [https://developers.google.com/workspace/calendar/api/guides/sync?hl=ko#legacy_synchronization]
이 가이드에서는 캘린더 데이터의 '증분 동기화'를 구현하는 방법을 설명합니다. 이 방법을 사용하면 대역폭을 절약하면서 모든 캘린더 컬렉션의 데이터를 동기화 상태로 유지할 수 있습니다.
개요
증분 동기화는 다음 두 단계로 구성됩니다.
초기 전체 동기화는 클라이언트의 상태를 서버의 상태와 완전히 동기화하기 위해 시작 시 한 번 실행됩니다. 클라이언트는 유지해야 하는 동기화 토큰을 획득합니다.
증분 동기화는 반복적으로 실행되며 이전 동기화 이후 발생한 모든 변경사항으로 클라이언트를 업데이트합니다. 매번 클라이언트는 서버에서 가져온 이전 동기화 토큰을 제공하고 응답에서 새 동기화 토큰을 저장합니다.
동기화 토큰은 서버와 클라이언트 간에 교환되는 데이터 조각으로, 동기화 프로세스에서 중요한 역할을 합니다. 예를 들면 다음과 같습니다.
"nextSyncToken": "CPDAlvWDx70CEPDAlvWDx70CGAU=",
초기 전체 동기화
초기 전체 동기화는 동기화하려는 컬렉션의 모든 리소스에 대한 원래 요청입니다. 특정 리소스 하위 집합만 동기화하려는 경우 요청 매개변수를 사용하여 목록 요청을 제한할 수 있습니다.
목록 작업에 대한 응답에는 동기화 토큰을 나타내는 nextSyncToken 필드가 있습니다. nextSyncToken 값을 저장해야 합니다. 결과 집합이 너무 커서 응답이 페이지로 나누어지는 [https://developers.google.com/workspace/calendar/v3/pagination?hl=ko] 경우 nextSyncToken 필드는 마지막 페이지에만 표시됩니다.
페이지로 나누는 동안 새 항목이 표시되는 것에 대해 걱정할 필요가 없습니다. 새 항목이 누락되지 않습니다. 서버가 올바른 동기화 토큰을 생성하는 데 필요한 정보는 페이지 토큰에 인코딩됩니다.
증분 동기화
증분 동기화를 사용하면 마지막 동기화 요청 이후 수정된 모든 리소스를 가져올 수 있습니다. 이렇게 하려면 syncToken 필드에 지정된 최신 동기화 토큰으로 목록 요청을 실행해야 합니다. 결과에는 항상 삭제된 항목이 포함되므로 클라이언트가 저장소에서 삭제할 수 있습니다.
마지막 증분 동기화 요청 이후 많은 리소스가 변경된 경우 목록 결과에 syncToken 대신 pageToken가 표시될 수 있습니다. 이러한 경우 증분 동기화에서 첫 번째 페이지를 가져오는 데 사용된 것과 정확히 동일한 목록 쿼리(정확히 동일한 syncToken 사용)를 실행하고, pageToken을 추가하고, 마지막 페이지에서 다른 syncToken을 찾을 때까지 모든 후속 요청을 통해 페이지로 나눕니다. 나중에 다음 동기화 요청을 위해 이 syncToken를 저장해야 합니다.
증분 페이지로 구분된 동기화가 필요한 케이스의 쿼리 예시는 다음과 같습니다.
원래 질문
GET /calendars/primary/events?maxResults=10&singleEvents=true&syncToken=CPDAlvWDx70CEPDAlvWDx

// Result contains the following

"nextPageToken":"CiAKGjBpNDd2Nmp2Zml2cXRwYjBpOXA",
다음 페이지 가져오는 중
GET /calendars/primary/events?maxResults=10&singleEvents=true&syncToken=CPDAlvWDx70CEPDAlvWDx&pageToken=CiAKGjBpNDd2Nmp2Zml2cXRwYjBpOXA
증분 동기화에 사용할 수 있는 쿼리 매개변수 집합이 제한됩니다. 각 목록 요청은 초기 요청을 포함하여 동일한 쿼리 매개변수 세트를 사용해야 합니다. 각 컬렉션의 개별 제한사항은 목록 요청에 관한 해당 문서를 참고하세요. 허용되지 않는 제한사항이 포함된 목록 쿼리의 응답 코드는 400입니다.
서버에서 전체 동기화 필요
동기화 토큰은 토큰 만료 또는 관련 ACL 변경 등 다양한 이유로 서버에 의해 무효화되는 경우가 있습니다. 이 경우 서버는 증분 요청에 410 응답 코드로 응답합니다. 이렇게 하면 클라이언트 저장소의 전체 삭제와 새로운 전체 동기화가 트리거됩니다.
샘플 코드
아래의 샘플 코드 스니펫은 Java 클라이언트 라이브러리 [https://developers.google.com/api-client-library/java/apis/calendar/v3?hl=ko]와 함께 동기화 토큰을 사용하는 방법을 보여줍니다. run 메서드가 처음 호출되면 전체 동기화를 실행하고 동기화 토큰을 저장합니다. 이후 실행에서는 저장된 동기화 토큰을 로드하고 증분 동기화를 실행합니다.
  private static void run() throws IOException {
    // Construct the {@link Calendar.Events.List} request, but don't execute it yet.
    Calendar.Events.List request = client.events().list("primary");

    // Load the sync token stored from the last execution, if any.
    String syncToken = syncSettingsDataStore.get(SYNC_TOKEN_KEY);
    if (syncToken == null) {
      System.out.println("Performing full sync.");

      // Set the filters you want to use during the full sync. Sync tokens aren't compatible with
      // most filters, but you may want to limit your full sync to only a certain date range.
      // In this example we are only syncing events up to a year old.
      Date oneYearAgo = Utils.getRelativeDate(java.util.Calendar.YEAR, -1);
      request.setTimeMin(new DateTime(oneYearAgo, TimeZone.getTimeZone("UTC")));
    } else {
      System.out.println("Performing incremental sync.");
      request.setSyncToken(syncToken);
    }

    // Retrieve the events, one page at a time.
    String pageToken = null;
    Events events = null;
    do {
      request.setPageToken(pageToken);

      try {
        events = request.execute();
      } catch (GoogleJsonResponseException e) {
        if (e.getStatusCode() == 410) {
          // A 410 status code, "Gone", indicates that the sync token is invalid.
          System.out.println("Invalid sync token, clearing event store and re-syncing.");
          syncSettingsDataStore.delete(SYNC_TOKEN_KEY);
          eventDataStore.clear();
          run();
        } else {
          throw e;
        }
      }

      List<Event> items = events.getItems();
      if (items.size() == 0) {
        System.out.println("No new events to sync.");
      } else {
        for (Event event : items) {
          syncEvent(event);
        }
      }

      pageToken = events.getNextPageToken();
    } while (pageToken != null);

    // Store the sync token from the last request to be used during the next execution.
    syncSettingsDataStore.set(SYNC_TOKEN_KEY, events.getNextSyncToken());

    System.out.println("Sync complete.");
  }
SyncTokenSample.java [https://github.com/googleworkspace/java-samples/blob/b30298095f654ff9952a691333f0aa5862ab935c/calendar/sync/src/main/java/com/google/api/services/samples/calendar/sync/SyncTokenSample.java]
기존 동기화
이벤트 컬렉션의 경우 이벤트 목록 요청에서 업데이트된 필드의 값을 보존한 다음 modifiedSince 필드를 사용하여 업데이트된 이벤트를 검색하여 기존 방식으로 동기화를 실행할 수 있습니다. 이 방법은 쿼리 제한을 적용하지 않는 경우와 같이 업데이트 누락과 관련하여 오류가 발생하기 쉬우므로 더 이상 권장되지 않습니다. 또한 이벤트에만 사용할 수 있습니다.
의견 보내기