Source URL: https://developers.google.com/identity/protocols/oauth2/service-account

이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.
Switch to English
홈 [https://developers.google.com/?hl=ko]
제품 [https://developers.google.com/products?hl=ko]
Google Identity [https://developers.google.com/identity?hl=ko]
승인 [https://developers.google.com/identity/protocols/oauth2?hl=ko]
Authorization [https://developers.google.com/identity/authorization?hl=ko]
의견 보내기
서버 간 애플리케이션에 OAuth 2.0 사용
bookmark_border
이 페이지의 내용
개요
서비스 계정 만들기
서비스 계정에 도메인 전체 권한 위임
위임된 API 호출
Google API 호출
JWT 오류 코드
부록: OAuth 없이 서비스 계정 승인
계정 간 보안 구현
<0x0 자세한 내용은 Google Cloud 문서의 인증 개요 [https://cloud.google.com/docs/authentication/?hl=ko]를 참고하세요.
Google OAuth 2.0 시스템은 웹 애플리케이션과 Google 서비스 간 상호작용과 같은 서버 간 상호작용을 지원합니다. 이 시나리오에서는 개별 최종 사용자가 아닌 애플리케이션에 속한 계정인 서비스 계정이 필요합니다. 애플리케이션은 서비스 계정을 대신하여 Google API를 호출하므로 사용자가 직접 관여하지 않습니다. 이 시나리오를 '2-legged OAuth' 또는 '2LO'라고도 합니다. (관련 용어인 '3-legged OAuth'는 애플리케이션이 최종 사용자를 대신하여 Google API를 호출하고 사용자 동의가 필요한 경우를 나타냅니다.)
일반적으로 애플리케이션이 Google API를 사용하여 사용자 데이터가 아닌 자체 데이터로 작업하는 경우 서비스 계정을 사용합니다. 예를 들어 데이터 지속성을 위해 Google Cloud Datastore를 사용하는 애플리케이션은 서비스 계정을 사용하여 Google Cloud Datastore API에 대한 호출을 인증합니다.
Google Workspace 도메인 관리자는 서비스 계정에 도메인 전체 권한을 부여 [https://developers.google.com/identity/protocols/oauth2/service-account?hl=ko#delegatingauthority]하여 도메인의 사용자를 대신하여 사용자 데이터에 액세스할 수도 있습니다.
이 문서에서는 애플리케이션이 Google API 클라이언트 라이브러리 (권장) 또는 HTTP를 사용하여 서버 간 OAuth 2.0 흐름을 완료하는 방법을 설명합니다.
일부 Google API에서는 OAuth 2.0을 사용하는 대신 서명된 JWT를 사용하여 인증된 API 호출을 수행할 수 있으므로 네트워크 요청을 절약할 수 있습니다. 부록: OAuth 없이 서비스 계정 승인 [https://developers.google.com/identity/protocols/oauth2/service-account?hl=ko#jwt-auth]을 참고하세요.
개요
서버 간 상호작용을 지원하려면 먼저 API Console에서 프로젝트의 서비스 계정을 만듭니다. Google Workspace 계정의 사용자 데이터를 액세스하려면 서비스 계정에 도메인 전체 액세스 권한을 위임하세요.
그런 다음 애플리케이션은 서비스 계정의 사용자 인증 정보를 사용하여 OAuth 2.0 인증 서버에서 액세스 토큰을 요청하여 승인된 API 호출을 준비합니다.
마지막으로 애플리케이션은 액세스 토큰을 사용하여 Google API를 호출할 수 있습니다.
권장사항: 애플리케이션은 언어에 맞는 Google API 클라이언트 라이브러리를 사용하거나 HTTP를 사용하여 OAuth 2.0 시스템과 직접 상호작용하여 이러한 작업을 완료할 수 있습니다. 하지만 서버 간 인증 상호작용의 메커니즘에서는 애플리케이션이 JSON 웹 토큰 (JWT)을 만들고 암호화 서명해야 하므로 실수로 인해 애플리케이션의 보안에 심각한 영향을 미칠 수 있는 심각한 오류가 발생할 수 있습니다.
따라서 Google API 클라이언트 라이브러리와 같이 애플리케이션 코드에서 암호화를 추상화하는 라이브러리를 사용하는 것이 좋습니다.
서비스 계정 만들기
서비스 계정의 사용자 인증 정보에는 고유하고 하나 이상의 공개 키/비공개 키 쌍이 있는 생성된 이메일 주소가 포함됩니다. 도메인 전체 위임이 사용 설정된 경우 클라이언트 ID도 서비스 계정의 사용자 인증 정보에 포함됩니다.
애플리케이션이 Google App Engine에서 실행되는 경우 프로젝트를 만들 때 서비스 계정이 자동으로 설정됩니다.
애플리케이션이 Google Compute Engine에서 실행되는 경우 프로젝트를 만들 때 서비스 계정도 자동으로 설정되지만 Google Compute Engine 인스턴스를 만들 때 애플리케이션에 필요한 액세스 범위를 지정해야 합니다. 자세한 내용은 서비스 계정을 사용하도록 인스턴스 준비 [https://cloud.google.com/compute/docs/access/create-enable-service-accounts-for-instances?hl=ko#using]를 참고하세요.
애플리케이션이 Google App Engine 또는 Google Compute Engine에서 실행되지 않는 경우 Google API Console에서 이러한 사용자 인증 정보를 획득해야 합니다. 서비스 계정 사용자 인증 정보를 생성하거나 이미 생성한 공개 사용자 인증 정보를 보려면 다음 단계를 따르세요.
먼저 서비스 계정을 만듭니다.
Service accounts page [https://console.developers.google.com/iam-admin/serviceaccounts?hl=ko]엽니다.
If prompted, select a project, or create a new one.
add 서비스 계정 만들기를 클릭합니다.
서비스 계정 세부정보 에서 서비스 계정의 이름, ID 및 설명을 입력한 다음 생성 및 계속 을 클릭합니다.
선택 사항: 이 서비스 계정에 프로젝트에 대한 액세스 권한 부여 아래에서 서비스 계정에 부여할 IAM 역할을 선택합니다.
계속 을 클릭합니다.
선택 사항: 사용자에게 이 서비스 계정에 대한 액세스 권한 부여 아래에서 서비스 계정을 사용하고 관리할 수 있는 사용자 또는 그룹을 추가합니다.
완료 를 클릭합니다.
다음으로 서비스 계정 키를 만듭니다.
생성한 서비스 계정의 이메일 주소를 클릭합니다.
키 탭을 클릭합니다.
키 추가 드롭다운 목록에서 새 키 만들기 를 선택합니다.
만들기 를 클릭합니다.
새로운 공개/개인 키 쌍이 생성되어 컴퓨터에 다운로드됩니다. 개인 키의 유일한 복사본 역할을 합니다. 안전하게 보관할 책임은 귀하에게 있습니다. 이 키 쌍을 분실하면 새 키 쌍을 생성해야 합니다.
언제든지 API Console [https://console.developers.google.com/?hl=ko]로 돌아가 이메일 주소, 공개 키 지문, 기타 정보를 확인하거나 추가 공개/비공개 키 쌍을 생성할 수 있습니다. API Console의 서비스 계정 사용자 인증 정보에 대한 자세한 내용은 API Console도움말 파일의 서비스 계정 [https://cloud.google.com/iam/docs/understanding-service-accounts?hl=ko]을 참고하세요.
서비스 계정의 이메일 주소를 기록하고 서비스 계정의 비공개 키 파일을 애플리케이션에서 액세스할 수 있는 위치에 저장합니다. 애플리케이션이 승인된 API 호출을 수행하려면 이러한 권한이 필요합니다.
참고: 개발 및 프로덕션 환경 모두에서 비공개 키를 안전하게 저장하고 관리해야 합니다. Google은 비공개 키의 사본을 보관하지 않고 공개 키만 보관합니다. 자세한 내용은 OAuth 2.0 정책의 클라이언트 사용자 인증 정보를 안전하게 처리하는 섹션 [https://developers.google.com/identity/protocols/oauth2/policies?hl=ko#secure-credentials]을 참고하세요.
서비스 계정에 도메인 전체 권한 위임
조직의 Workspace 관리자는 Google Workspace 계정을 사용하여 애플리케이션이 Google Workspace 도메인의 사용자를 대신하여 Workspace 사용자 데이터에 액세스하도록 승인할 수 있습니다. 예를 들어 Google Calendar API를 통해 Google Workspace 도메인에 속한 모든 사용자의 캘린더에 이벤트를 추가하는 애플리케이션은 서비스 계정을 사용하여 Google Calendar API에 사용자 대신 액세스합니다. 도메인의 사용자 대신 데이터에 액세스하도록 서비스 계정을 승인하는 것을 서비스 계정에 대한 '도메인 전체 권한 위임'이라 합니다.
참고: Google Workspace Marketplace를 사용하여 도메인용 애플리케이션을 설치하면 설치 중에 필요한 권한이 애플리케이션에 자동으로 부여됩니다. 애플리케이션에서 사용하는 서비스 계정을 수동으로 승인할 필요가 없습니다.
참고: Google Workspace 도메인에서 실행되는 애플리케이션에서 서비스 계정을 사용할 수 있지만 서비스 계정은 Google Workspace 계정의 구성원이 아니며 Google Workspace 관리자가 설정한 도메인 정책이 적용되지 않습니다. 예를 들어 Google Workspace 최종 사용자가 도메인 외부로 문서를 공유하는 기능을 제한하도록 Google Workspace 관리 콘솔에서 설정된 정책은 서비스 계정에는 적용되지 않습니다.
서비스 계정에 도메인 전체 권한을 위임하려면 Google Workspace 도메인의 최고 관리자가 다음 단계를 완료해야 합니다.
Google Workspace 도메인의 관리 콘솔 [https://admin.google.com/?hl=ko]에서 기본 메뉴 menu > 보안 > 액세스 및 데이터 컨트롤 > API 컨트롤로 이동합니다.
도메인 전체 위임 창에서 도메인 전체 위임 관리를 선택합니다.
새로 추가를 클릭합니다.
클라이언트 ID 필드에 서비스 계정의 클라이언트 ID를 입력합니다. Service accounts page [https://console.developers.google.com/iam-admin/serviceaccounts?hl=ko]에서 서비스 계정의 클라이언트 ID를 확인할 수 있습니다.
OAuth 범위 (쉼표로 구분) 필드에 애플리케이션에 액세스 권한이 부여되어야 하는 범위 목록을 입력합니다. 예를 들어 애플리케이션에서 Google Drive API 및 Google Calendar API에 대한 도메인 전체 전체 액세스 권한이 필요하면 https://www.googleapis.com/auth/drive, https://www.googleapis.com/auth/calendar를 입력합니다.
승인을 클릭합니다.
이제 애플리케이션이 Workspace 도메인의 사용자로 API를 호출할 수 있습니다 (사용자 '가장'). 이러한 위임된 API 호출을 준비할 때 가장할 사용자를 명시적으로 지정합니다.
참고: 클라이언트 ID가 추가된 후 가장 액세스 권한이 부여되기까지 보통 몇 분이 걸리지만, 경우에 따라 Google 계정의 모든 사용자에게 전파되기까지 최대 24시간이 걸릴 수 있습니다.
위임된 API 호출
--- 탭: 자바 ---
GoogleCredentials credentials = GoogleCredentials.fromStream(new FileInputStream("MyProject-1234.json"))
    .createScoped(Collections.singleton(SQLAdminScopes.SQLSERVICE_ADMIN))
    .createDelegated("workspace-user@example.com");

--- 탭: Python ---
API Console에서 클라이언트 이메일 주소와 비공개 키를 가져온 후 Python용 Google API 클라이언트 라이브러리 [https://github.com/googleapis/google-api-python-client/blob/master/docs/oauth.md]를 사용하여 다음 단계를 완료합니다.

      
        서비스 계정의 사용자 인증 정보와 애플리케이션이 액세스해야 하는 범위에서 Credentials 객체를 만듭니다. 예를 들면 다음과 같습니다.

          from google.oauth2 import service_account

SCOPES = ['https://www.googleapis.com/auth/sqlservice.admin']
SERVICE_ACCOUNT_FILE = '/path/to/service.json'

credentials = service_account.Credentials.from_service_account_file(
        SERVICE_ACCOUNT_FILE, scopes=SCOPES)
          Google Cloud에서 앱을 개발하는 경우 애플리케이션 기본 사용자 인증 정보 [https://cloud.google.com/docs/authentication/production?hl=ko#providing_credentials_to_your_application]를 대신 사용할 수 있습니다. 그러면 프로세스가 간소화됩니다.
        도메인 전체 권한 위임
          서비스 계정에 도메인 전체 액세스 권한을 위임했고 사용자 계정을 가장하려면 기존 ServiceAccountCredentials 객체의 with_subject 메서드를 사용하세요. 예를 들면 다음과 같습니다.

          delegated_credentials = credentials.with_subject('user@example.org')
      

      사용자 인증 정보 객체를 사용하여 애플리케이션에서 Google API를 호출합니다.

--- 탭: HTTP/REST ---
권장사항: 애플리케이션이 HTTP를 사용하여 OAuth 2.0 시스템과 직접 상호작용하여 이러한 작업을 완료할 수 있지만 서버 간 인증 상호작용의 메커니즘에서는 애플리케이션이 JSON 웹 토큰 (JWT)을 만들고 암호화 서명해야 하므로 실수로 인해 애플리케이션의 보안에 심각한 영향을 미칠 수 있는 심각한 오류가 발생할 수 있습니다.

        따라서 Google API 클라이언트 라이브러리와 같이 애플리케이션 코드에서 암호화를 추상화하는 라이브러리를 사용하는 것이 좋습니다.

       API Console에서 클라이언트 ID와 비공개 키를 가져온 후 애플리케이션은 다음 단계를 완료해야 합니다.

      
        헤더, 클레임 세트, 서명이 포함된 JSON 웹 토큰 (JWT, 발음: '조트')을 만듭니다.
        Google OAuth 2.0 승인 서버에서 액세스 토큰을 요청합니다.
        인증 서버가 반환하는 JSON 응답을 처리합니다.
      

      다음 섹션에서는 이러한 단계를 완료하는 방법을 설명합니다.

      응답에 액세스 토큰이 포함된 경우 액세스 토큰을 사용하여 Google API를 호출 [https://developers.google.com/identity/protocols/oauth2/service-account?hl=ko#callinganapi]할 수 있습니다. (응답에 액세스 토큰이 포함되지 않으면 JWT 및 토큰 요청이 올바르게 구성되지 않았거나 서비스 계정에 요청된 범위에 액세스할 권한이 없을 수 있습니다.)

      액세스 토큰이 만료 [https://developers.google.com/identity/protocols/oauth2/service-account?hl=ko#expiration]되면 애플리케이션에서 다른 JWT를 생성하고 서명한 후 다른 액세스 토큰을 요청합니다.

      그림 1. 서버 애플리케이션은 JWT를 사용하여 Google 승인 서버에 토큰을 요청한 다음 토큰을 사용하여 Google API 엔드포인트를 호출합니다. 최종 사용자가 관여하지 않습니다.
        
      

      이 섹션의 나머지 부분에서는 JWT 생성, JWT 서명, 액세스 토큰 요청 형성, 응답 처리의 세부사항을 설명합니다.

      

        JWT 만들기

        JWT는 헤더, 클레임 세트, 서명 등 세 부분으로 구성됩니다. 헤더 및 클레임 세트는 JSON 객체입니다. 이러한 JSON 객체는 UTF-8 바이트로 직렬화된 후 Base64url 인코딩을 사용하여 인코딩됩니다. 이 인코딩은 반복된 인코딩 작업으로 인한 인코딩 변경에 대한 복원력을 제공합니다. 헤더, 클레임 세트, 서명은 마침표 (.) 문자와 함께 연결됩니다.

        JWT는 다음과 같이 구성됩니다.

        {Base64url encoded header}.{Base64url encoded claim set}.{Base64url encoded signature}

        서명의 기본 문자열은 다음과 같습니다.

        {Base64url encoded header}.{Base64url encoded claim set}

        JWT 헤더 구성

        헤더는 서명 알고리즘과 어설션 형식이라는 두 개의 필수 필드와 선택적 키 ID로 구성됩니다.
          
            알고리즘은 필수이며 값은 "alg": "RS256" 하나만 있습니다.
            형식은 필수이며 값은 "typ": "JWT" 하나만 있습니다.
            키 ID는 선택사항이며 JWT에 서명하는 데 사용되는 서비스 계정 키의 ID [https://cloud.google.com/iam/docs/reference/rest/v1/projects.serviceAccounts.keys?hl=ko]입니다. 잘못된 키 ID가 지정되면 서비스 계정과 연결된 모든 키가 시도됩니다. 유효한 키가 없으면 토큰이 거부됩니다. Google은 키 ID가 잘못된 토큰을 거부할 권리를 보유합니다.
            
          
        서비스 계정은 RSA SHA-256 알고리즘과 JWT 토큰 형식을 사용합니다. 따라서 헤더의 JSON 표현은 다음과 같습니다.

        {"alg":"RS256","typ":"JWT", "kid":"370ab79b4513eb9bad7c9bd16a95cb76b5b2a56a"}

        이 값의 Base64url 표현은 다음과 같습니다.

        eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsICJraWQiOiIzNzBhYjc5YjQ1MTNlYjliYWQ3YzliZDE2YTk1Y2I3NmI1YjJhNTZhIn0=

        JWT 클레임 세트 구성

        JWT 클레임 세트에는 요청된 권한 (범위), 토큰 대상, 발급기관, 토큰 발급 시간, 토큰 수명 등 JWT에 대한 정보가 포함됩니다. 대부분의 필드는 필수입니다. JWT 헤더와 마찬가지로 JWT 클레임 세트는 JSON 객체이며 서명 계산에 사용됩니다.

        필수 클레임

        JWT 클레임 세트의 필수 클레임은 클레임 세트에서 순서에 관계없이 표시될 수 있습니다.

        
          
            
              이름
              설명
            
          
          
            
              iss
              서비스 계정의 이메일 주소입니다.
            
            
              scope
              애플리케이션이 요청하는 공백으로 구분된 권한 목록입니다.
            
            
              aud
              어설션의 의도된 타겟에 대한 설명자입니다. 액세스 토큰 요청을 할 때 이 값은 항상 https://oauth2.googleapis.com/token입니다.
            
            
              exp
              어설션의 만료 시간으로, 1970년 1월 1일 00:00:00 UTC 이후의 초로 지정됩니다. 이 값은 발급 시간 후 최대 1시간입니다.
            
            
              iat
              어설션이 발급된 시간으로, 1970년 1월 1일 00:00:00 UTC 이후의 초로 지정됩니다.
            
          
        

        다음은 JWT 클레임 세트에서 필수 필드의 JSON 표현의 예입니다.

        {
  "iss": "761326798069-r5mljlln1rd4lrbhg75efgigp36m78j5@developer.gserviceaccount.com",
  "scope": "https://www.googleapis.com/auth/devstorage.read_only",
  "aud": "https://oauth2.googleapis.com/token",
  "exp": 1328554385,
  "iat": 1328550785
}

        추가 소유권 주장

        일부 엔터프라이즈 사례에서 애플리케이션은 도메인 전체 위임을 사용하여 조직의 특정 사용자를 대신하여 작업을 실행할 수 있습니다. 애플리케이션이 사용자를 가장하려면 먼저 이러한 유형의 가장을 실행할 권한이 부여되어야 하며, 일반적으로 최고 관리자가 이를 처리합니다. 자세한 내용은 도메인 전체 위임으로 API 액세스 제어하기 [https://support.google.com/a/answer/162106?hl=ko]를 참고하세요.

        애플리케이션에 리소스에 대한 위임된 액세스 권한을 부여하는 액세스 토큰을 가져오려면 JWT 클레임 집합에 사용자의 이메일 주소를 sub 필드의 값으로 포함합니다.

        
          
            
              이름
              설명
            
          
          
            
              sub
              애플리케이션이 위임된 액세스를 요청하는 사용자의 이메일 주소입니다.
            
          
        

        애플리케이션에 사용자 가장 권한이 없으면 sub 필드가 포함된 액세스 토큰 요청에 대한 응답은 error [https://developers.google.com/identity/protocols/oauth2/service-account?hl=ko#error-codes]가 됩니다.

        다음은 sub 필드가 포함된 JWT 클레임 세트의 예입니다.

        {
  "iss": "761326798069-r5mljlln1rd4lrbhg75efgigp36m78j5@developer.gserviceaccount.com",
  "sub": "some.user@example.com",
  "scope": "https://www.googleapis.com/auth/prediction",
  "aud": "https://oauth2.googleapis.com/token",
  "exp": 1328554385,
  "iat": 1328550785
}

        JWT 클레임 집합 인코딩

        JWT 헤더와 마찬가지로 JWT 클레임 세트는 UTF-8로 직렬화되고 Base64url-safe로 인코딩되어야 합니다. 다음은 JWT 클레임 세트의 JSON 표현의 예입니다.

        {
  "iss": "761326798069-r5mljlln1rd4lrbhg75efgigp36m78j5@developer.gserviceaccount.com",
  "scope": "https://www.googleapis.com/auth/prediction",
  "aud": "https://oauth2.googleapis.com/token",
  "exp": 1328554385,
  "iat": 1328550785
}

        서명 계산

        JSON 웹 서명 [https://tools.ietf.org/html/rfc7515](JWS)은 JWT 서명을 생성하는 메커니즘을 안내하는 사양입니다. 서명 입력은 다음 콘텐츠의 바이트 배열입니다.

        {Base64url encoded header}.{Base64url encoded claim set}

        서명을 계산할 때는 JWT 헤더의 서명 알고리즘을 사용해야 합니다. Google OAuth 2.0 승인 서버에서 지원하는 유일한 서명 알고리즘은 SHA-256 해싱 알고리즘을 사용하는 RSA입니다. JWT 헤더의 alg 필드에서 RS256으로 표시됩니다.

         Google API Console [https://console.developers.google.com/?hl=ko]에서 획득한 비공개 키를 사용하여 SHA256withRSA (SHA-256 해시 함수를 사용한 RSASSA-PKCS1-V1_5-SIGN이라고도 함)로 입력의 UTF-8 표현에 서명합니다. 출력은 바이트 배열입니다.

        그런 다음 서명을 Base64url로 인코딩해야 합니다. 헤더, 클레임 세트, 서명은 마침표 (.) 문자와 함께 연결됩니다. 결과는 JWT입니다. 다음과 같아야 합니다 (보기 편하게 하기 위해 줄바꿈 추가).

        {Base64url encoded header}.
{Base64url encoded claim set}.
{Base64url encoded signature}

        다음은 Base64url 인코딩 전의 JWT의 예입니다.

        {"alg":"RS256","typ":"JWT"}.
{
"iss":"761326798069-r5mljlln1rd4lrbhg75efgigp36m78j5@developer.gserviceaccount.com",
"scope":"https://www.googleapis.com/auth/prediction",
"aud":"https://oauth2.googleapis.com/token",
"exp":1328554385,
"iat":1328550785
}.
[signature bytes]

        다음은 서명되어 전송 준비가 완료된 JWT의 예시입니다.

        eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiI3NjEzMjY3OTgwNjktcjVtbGpsbG4xcmQ0bHJiaGc3NWVmZ2lncDM2bTc4ajVAZGV2ZWxvcGVyLmdzZXJ2aWNlYWNjb3VudC5jb20iLCJzY29wZSI6Imh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvcHJlZGljdGlvbiIsImF1ZCI6Imh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL29hdXRoMi92NC90b2tlbiIsImV4cCI6MTMyODU1NDM4NSwiaWF0IjoxMzI4NTUwNzg1fQ.UFUt59SUM2_AW4cRU8Y0BYVQsNTo4n7AFsNrqOpYiICDu37vVt-tw38UKzjmUKtcRsLLjrR3gFW3dNDMx_pL9DVjgVHDdYirtrCekUHOYoa1CMR66nxep5q5cBQ4y4u2kIgSvChCTc9pmLLNoIem-ruCecAJYgI9Ks7pTnW1gkOKs0x3YpiLpzplVHAkkHztaXiJdtpBcY1OXyo6jTQCa3Lk2Q3va1dPkh_d--GU2M5flgd8xNBPYw4vxyt0mP59XZlHMpztZt0soSgObf7G3GXArreF_6tpbFsS3z2t5zkEiHuWJXpzcYr5zWTRPDEHsejeBSG8EgpLDce2380ROQ

      

      

        액세스 토큰 요청

        서명된 JWT를 생성한 후 애플리케이션에서 이를 사용하여 액세스 토큰을 요청할 수 있습니다.
          이 액세스 토큰 요청은 HTTPS POST 요청이며 본문은 URL로 인코딩됩니다. 예를 들면 다음과 같습니다.

        https://oauth2.googleapis.com/token

        HTTPS POST 요청에는 다음 매개변수가 필요합니다.

        
          
            
              이름
              설명
            
          
          
            
              grant_type
              필요에 따라 URL로 인코딩된 다음 문자열을 사용합니다.
                urn:ietf:params:oauth:grant-type:jwt-bearer
            
            
              assertion
              서명을 포함한 JWT입니다.
            
          
        

        액세스 토큰 요청에 사용된 HTTPS POST 요청의 원시 덤프는 다음과 같습니다.

        POST /token HTTP/1.1
Host: oauth2.googleapis.com
Content-Type: application/x-www-form-urlencoded

grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer&assertion=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiI3NjEzMjY3OTgwNjktcjVtbGpsbG4xcmQ0bHJiaGc3NWVmZ2lncDM2bTc4ajVAZGV2ZWxvcGVyLmdzZXJ2aWNlYWNjb3VudC5jb20iLCJzY29wZSI6Imh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvcHJlZGljdGlvbiIsImF1ZCI6Imh0dHBzOi8vYWNjb3VudHMuZ29vZ2xlLmNvbS9vL29hdXRoMi90b2tlbiIsImV4cCI6MTMyODU3MzM4MSwiaWF0IjoxMzI4NTY5NzgxfQ.ixOUGehweEVX_UKXv5BbbwVEdcz6AYS-6uQV6fGorGKrHf3LIJnyREw9evE-gs2bmMaQI5_UbabvI4k-mQE4kBqtmSpTzxYBL1TCd7Kv5nTZoUC1CmwmWCFqT9RE6D7XSgPUh_jF1qskLa2w0rxMSjwruNKbysgRNctZPln7cqQ

        다음은 curl를 사용하는 동일한 요청입니다.

        curl -d 'grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer&assertion=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiI3NjEzMjY3OTgwNjktcjVtbGpsbG4xcmQ0bHJiaGc3NWVmZ2lncDM2bTc4ajVAZGV2ZWxvcGVyLmdzZXJ2aWNlYWNjb3VudC5jb20iLCJzY29wZSI6Imh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvcHJlZGljdGlvbiIsImF1ZCI6Imh0dHBzOi8vYWNjb3VudHMuZ29vZ2xlLmNvbS9vL29hdXRoMi90b2tlbiIsImV4cCI6MTMyODU3MzM4MSwiaWF0IjoxMzI4NTY5NzgxfQ.RZVpzWygMLuL-n3GwjW1_yhQhrqDacyvaXkuf8HcJl8EtXYjGjMaW5oiM5cgAaIorrqgYlp4DPF_GuncFqg9uDZrx7pMmCZ_yHfxhSCXru3gbXrZvAIicNQZMFxrEEn4REVuq7DjkTMyCMGCY1dpMa8aWfTQFt3Eh7smLchaZsU
' https://oauth2.googleapis.com/token

      

      

        응답 처리

        JWT 및 액세스 토큰 요청이 올바르게 구성되고 서비스 계정에 작업을 실행할 권한이 있으면 승인 서버의 JSON 응답에 액세스 토큰이 포함됩니다. 다음은 응답 예시입니다.

        {
  "access_token": "1/8xbJqaOZXSUZbHLl5EOtu1pxz3fmmetKx9W8CV4t79M",
  "scope": "https://www.googleapis.com/auth/prediction"
  "token_type": "Bearer",
  "expires_in": 3600
}

        액세스 토큰은 expires_in 값으로 지정된 기간 창 동안 재사용할 수 있습니다.
중요한 보안 고려사항: 가장 이해하기
도메인 전체 권한을 위임해도 서비스 계정에 모든 사용자 데이터에 대한 직접 액세스 권한이 부여되지는 않습니다. 대신 API 호출 시 특정 사용자를 가장하도록 승인하는 것입니다.
사용자를 대신한 액세스: 애플리케이션은 각 API 요청에 대해 가장할 사용자를 지정해야 합니다. 그러면 애플리케이션은 상승된 권한이나 도메인 전체 권한 [https://developers.google.com/identity/protocols/oauth2/service-account?hl=ko#delegatingauthority]이 아닌 해당 특정 사용자의 권한으로 작동합니다.
권한 제한: 서비스 계정의 액세스는 가장된 사용자의 권한과 관리 콘솔에서 승인한 OAuth 범위라는 두 가지 요소에 의해 제한됩니다. 가장된 사용자가 액세스할 수 없는 데이터에는 액세스할 수 없습니다.
최소 권한 원칙: 이 기능을 사용하면 사용자의 직접적인 동의 없이 사용자 데이터에 액세스할 수 있으므로 보안 권장사항을 따르는 것이 중요합니다. 필요한 OAuth 범위만 부여하고 보안상의 영향을 파악해야 합니다.
자세한 보안 가이드라인은 도메인 전체 위임 권장사항 [https://support.google.com/a/answer/14437356?hl=ko]을 참고하세요.
Google API 호출
--- 탭: 자바 ---
GoogleCredentials 객체를 사용하여 다음 단계를 완료하여 Google API를 호출합니다.

      
        GoogleCredentials 객체를 사용하여 호출하려는 API의 서비스 객체를 만듭니다. 예를 들면 다음과 같습니다.
          SQLAdmin sqladmin =
    new SQLAdmin.Builder(httpTransport, JSON_FACTORY, credentials).build();
        
        서비스 객체에서 제공하는 인터페이스 [https://github.com/googleapis/google-api-java-client]를 사용하여 API 서비스에 요청합니다.
          예를 들어 exciting-example-123 프로젝트의 Cloud SQL 데이터베이스 인스턴스를 나열하려면 다음을 실행합니다.

          SQLAdmin.Instances.List instances =
    sqladmin.instances().list("exciting-example-123").execute();

--- 탭: Python ---
승인된 Credentials 객체를 사용하여 다음 단계를 완료하여 Google API를 호출합니다.

      
        호출하려는 API의 서비스 객체를 빌드합니다. API의 이름과 버전, 승인된 Credentials 객체로 build 함수를 호출하여 서비스 객체를 빌드합니다. 예를 들어 Cloud SQL Administration API의 버전 1beta3을 호출하려면 다음을 실행합니다.

          import googleapiclient.discovery

sqladmin = googleapiclient.discovery.build('sqladmin', 'v1beta3', credentials=credentials)
        
        서비스 객체에서 제공하는 인터페이스 [https://github.com/googleapis/google-api-python-client/blob/master/docs/oauth.md#service-account-credentials]를 사용하여 API 서비스에 요청합니다.
          예를 들어 exciting-example-123 프로젝트의 Cloud SQL 데이터베이스 인스턴스를 나열하려면 다음을 실행합니다.

          response = sqladmin.instances().list(project='exciting-example-123').execute()

--- 탭: HTTP/REST ---
애플리케이션이 액세스 토큰을 획득한 후에는 API에 필요한 액세스 범위가 부여된 경우 토큰을 사용하여 특정 서비스 계정 또는 사용자 계정을 대신하여 Google API를 호출할 수 있습니다. 이렇게 하려면 access_token 쿼리 매개변수 또는 Authorization HTTP 헤더 Bearer 값을 포함하여 API에 대한 요청에 액세스 토큰을 포함합니다. 가능한 경우 HTTP 헤더를 사용하는 것이 좋습니다. 쿼리 문자열은 서버 로그에 표시되는 경향이 있기 때문입니다. 대부분의 경우 클라이언트 라이브러리를 사용하여 Google API 호출을 설정할 수 있습니다 (예: Drive Files API 호출 [https://developers.google.com/drive/api/v2/reference?hl=ko#Files]).



OAuth 2.0 Playground [https://developers.google.com/oauthplayground/?hl=ko]에서 모든 Google API를 사용해 보고 범위를 확인할 수 있습니다.

HTTP GET 예

Authorization: Bearer HTTP 헤더를 사용하여 drive.files [https://developers.google.com/drive/v2/reference/files/list?hl=ko] 엔드포인트 (Drive Files API)를 호출하는 것은 다음과 같습니다. 자체 액세스 토큰을 지정해야 합니다.

GET /drive/v2/files HTTP/1.1
Host: www.googleapis.com
Authorization: Bearer access_token

다음은 access_token 쿼리 문자열 매개변수를 사용하여 인증된 사용자에 대해 동일한 API를 호출하는 것입니다.

GET https://www.googleapis.com/drive/v2/files?access_token=access_token

curl 예

curl 명령줄 애플리케이션으로 이러한 명령어를 테스트할 수 있습니다. 다음은 HTTP 헤더 옵션을 사용하는 예입니다 (권장).

curl -H "Authorization: Bearer access_token" https://www.googleapis.com/drive/v2/files

또는 쿼리 문자열 매개변수 옵션:

curl https://www.googleapis.com/drive/v2/files?access_token=access_token

      

        액세스 토큰이 만료되는 경우

        Google OAuth 2.0 승인 서버에서 발급한 액세스 토큰은 expires_in 값으로 제공된 기간이 지나면 만료됩니다. 액세스 토큰이 만료되면 애플리케이션에서 다른 JWT를 생성하고 서명한 후 다른 액세스 토큰을 요청해야 합니다.
JWT 오류 코드
error 필드 error_description 필드 의미 해결 방법
unauthorized_client Unauthorized client or scope in request. 도메인 전체 위임을 사용하려고 하는데 서비스 계정이 사용자 도메인의 관리 콘솔에서 승인되지 않았습니다.
서비스 계정이 sub 클레임 (필드)의 사용자에 대해 관리 콘솔의 도메인 전체 위임 [https://support.google.com/a/answer/162106?hl=ko] 페이지에서 승인되었는지 확인합니다.
일반적으로 몇 분 정도 걸리지만, 승인이 Google 계정의 모든 사용자에게 전파되는 데 최대 24시간이 걸릴 수 있습니다.
unauthorized_client Client is unauthorized to retrieve access tokens using this method, or client not authorized for any of the scopes requested. 관리 콘솔에서 클라이언트 ID(숫자)가 아닌 클라이언트 이메일 주소를 사용하여 서비스 계정이 승인되었습니다. 관리 콘솔의 도메인 전체 위임 [https://support.google.com/a/answer/162106?hl=ko] 페이지에서 클라이언트를 삭제하고 숫자 ID를 사용하여 다시 추가합니다.
access_denied (모든 값) 도메인 전체 위임을 사용하는 경우 요청된 범위 중 하나 이상이 관리 콘솔에서 승인되지 않았습니다.
서비스 계정이 관리 콘솔의 도메인 전체 위임 [https://support.google.com/a/answer/162106?hl=ko] 페이지에서 sub 클레임 (필드)의 사용자에 대해 승인되었는지, JWT의 scope 클레임에 요청하는 모든 범위가 포함되어 있는지 확인합니다.
개별 설정이 없는 서비스 관리하기 [https://support.google.com/a/answer/7646040?hl=ko]를 검토하여 Google 서비스에 대한 액세스가 제한되지 않는지 확인합니다.
일반적으로 몇 분 정도 걸리지만, 승인이 Google 계정의 모든 사용자에게 전파되는 데 최대 24시간이 걸릴 수 있습니다.
admin_policy_enforced (모든 값) Google 계정의 Google Workspace 관리자 정책으로 인해 요청된 하나 이상의 범위를 승인할 수 없습니다.
관리자가 OAuth 클라이언트 ID에 대한 액세스 권한이 명시적으로 부여될 때까지 모든 범위 또는 민감하고 제한된 범위에 대한 액세스를 제한하는 방법에 대한 자세한 내용은 Google Workspace 관리자 도움말 Google Workspace 데이터에 액세스할 수 있는 서드 파티 및 내부 앱 제어하기 [https://support.google.com/a/answer/7281227?hl=ko]를 참고하세요.
invalid_client (모든 값)
OAuth 클라이언트 또는 JWT 토큰이 잘못되었거나 잘못 구성되었습니다.
자세한 내용은 오류 설명을 참고하세요.
JWT 토큰이 유효하고 올바른 클레임이 포함되어 있는지 확인합니다.
OAuth 클라이언트 및 서비스 계정 [https://developers.google.com/identity/protocols/oauth2/service-account?hl=ko#creatinganaccount]이 올바르게 구성되어 있고 올바른 이메일 주소를 사용하고 있는지 확인합니다.
JWT 토큰이 올바르고 요청의 클라이언트 ID에 대해 발급되었는지 확인합니다.
deleted_client (모든 값)
요청을 만드는 데 사용된 OAuth 클라이언트가 삭제되었습니다. 삭제는 수동으로 이루어질 수도 있고 사용하지 않는 클라이언트 [https://support.google.com/cloud/answer/15549257?hl=ko#unused-client-deletion]의 경우 자동으로 이루어질 수도 있습니다. 삭제된 클라이언트는 삭제 후 30일 이내에 복원할 수 있습니다. 자세히 알아보기 [https://support.google.com/cloud/answer/15549257?hl=ko#delete-oauth-clients]
여전히 활성 상태인 클라이언트 ID를 사용합니다.
invalid_grant Not a valid email. 존재하지 않는 사용자입니다. sub 클레임 (필드)의 이메일 주소가 올바른지 확인합니다.
invalid_grant
Invalid JWT: Token must be a short-lived token (60 minutes) and in a reasonable timeframe. Check your 'iat' and 'exp' values and use a clock with skew to account for clock differences between systems.
일반적으로 이는 로컬 시스템 시간이 올바르지 않음을 의미합니다. exp 값이 iat 값보다 65분 이상 미래에 있거나 exp 값이 iat 값보다 낮은 경우에도 발생할 수 있습니다.
JWT가 생성되는 시스템의 시계가 올바른지 확인합니다. 필요한 경우 Google NTP [https://developers.google.com/time?hl=ko]와 시간을 동기화합니다.
invalid_grant Invalid JWT Signature.
JWT 어설션이 클라이언트 이메일로 식별되는 서비스 계정과 연결되지 않은 비공개 키로 서명되었거나 사용된 키가 삭제, 사용 중지 또는 만료되었습니다.
또는 JWT 어설션이 잘못 인코딩되었을 수 있습니다. 줄바꿈이나 패딩 등호 없이 Base64로 인코딩되어야 합니다.
JWT 클레임 세트를 디코딩하고 어설션에 서명한 키가 서비스 계정과 연결되어 있는지 확인합니다.
Google 제공 OAuth 라이브러리를 사용하여 JWT가 올바르게 생성되는지 확인합니다.
invalid_scope Invalid OAuth scope or ID token audience provided. 요청된 범위가 없거나 (범위 목록이 비어 있음) 요청된 범위 중 하나가 존재하지 않습니다 (즉, 유효하지 않음).
JWT의 scope 클레임 (필드)이 채워져 있는지 확인하고, 포함된 범위를 사용하려는 API의 문서화된 범위와 비교하여 오류나 오타가 없는지 확인합니다.
scope 클레임의 범위 목록은 쉼표가 아닌 공백으로 구분해야 합니다.
disabled_client The OAuth client was disabled. JWT 어설션에 서명하는 데 사용된 키가 사용 중지되었습니다.
Google API Console [https://console.developers.google.com/?hl=ko]로 이동하여 IAM 및 관리자 > 서비스 계정에서 어설션을 서명하는 데 사용되는 '키 ID'가 포함된 서비스 계정을 사용 설정합니다.
org_internal This client is restricted to users within its organization. 요청의 OAuth 클라이언트 ID가 특정 Google Cloud 조직 [https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy?hl=ko#organizations]의 Google 계정에 대한 액세스를 제한하는 프로젝트에 속합니다.
조직의 서비스 계정을 사용하여 인증합니다. OAuth 애플리케이션의 사용자 유형 구성 [https://support.google.com/cloud/answer/10311615?hl=ko#user-type]을 확인합니다.
부록: OAuth 없이 서비스 계정 승인
일부 Google API의 경우 OAuth 2.0 액세스 토큰 대신 서명된 JWT를 Bearer 토큰으로 직접 사용하여 인증된 API 호출을 수행할 수 있습니다. 가능한 경우 API 호출을 수행하기 전에 Google의 승인 서버로 네트워크 요청을 수행하지 않아도 됩니다.
호출하려는 API에 Google API GitHub 저장소 [https://github.com/googleapis/googleapis]에 게시된 서비스 정의가 있는 경우 액세스 토큰 대신 JWT를 사용하여 승인된 API 호출을 할 수 있습니다. 방법은 다음과 같습니다.
서비스 계정을 만듭니다 [https://developers.google.com/identity/protocols/oauth2/service-account?hl=ko#creatinganaccount]. 계정을 만들 때 받은 JSON 파일을 보관해야 합니다.
jwt.io [https://jwt.io/#libraries-io]에서 찾을 수 있는 라이브러리와 같은 표준 JWT 라이브러리를 사용하여 다음 예와 같은 헤더와 페이로드가 있는 JWT를 만듭니다.
{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "abcdef1234567890"
}
.
{
  "iss": "123456-compute@developer.gserviceaccount.com",
  "sub": "123456-compute@developer.gserviceaccount.com",
  "aud": "https://firestore.googleapis.com/",
  "iat": 1511900000,
  "exp": 1511903600
}
헤더의 kid 필드에는 서비스 계정의 비공개 키 ID를 지정합니다. 이 값은 서비스 계정 JSON 파일의 private_key_id 필드에서 확인할 수 있습니다.
iss 및 sub 필드에 서비스 계정의 이메일 주소를 지정합니다. 이 값은 서비스 계정 JSON 파일의 client_email 필드에서 확인할 수 있습니다. 이 값은 클라이언트를 고유하게 식별하며 기능적으로는 클라이언트 ID입니다.
aud 필드에 API 엔드포인트를 지정합니다. 예를 들면 https://SERVICE.googleapis.com/입니다.
iat 필드에 현재 Unix 시간을 지정하고 exp 필드에는 JWT가 만료되는 3,600초 후의 시간을 지정합니다.
서비스 계정 JSON 파일에 있는 비공개 키를 사용하여 RSA-256으로 JWT에 서명합니다.
예를 들면 다음과 같습니다.
--- 탭: 자바 ---
google-auth-library-java [https://github.com/googleapis/google-auth-library-java] 및 java-jwt [https://github.com/auth0/java-jwt] 사용:

      import com.google.auth.oauth2.ServiceAccountCredentials;
...
GoogleCredentials credentials =
        GoogleCredentials.fromStream(new FileInputStream("MyProject-1234.json"));
PrivateKey privateKey = ((ServiceAccountCredentials) credentials).getPrivateKey();
String privateKeyId = ((ServiceAccountCredentials) credentials).getPrivateKeyId();

long now = System.currentTimeMillis();

try {
    Algorithm algorithm = Algorithm.RSA256(null, privateKey);
    String signedJwt = JWT.create()
        .withKeyId(privateKeyId)
        .withIssuer("123456-compute@developer.gserviceaccount.com")
        .withSubject("123456-compute@developer.gserviceaccount.com")
        .withAudience("https://firestore.googleapis.com/")
        .withIssuedAt(new Date(now))
        .withExpiresAt(new Date(now + 3600 * 1000L))
        .sign(algorithm);
} catch ...

--- 탭: Python ---
PyJWT [https://github.com/jpadilla/pyjwt/] 사용:

      iat = time.time()
exp = iat + 3600
payload = {'iss': '123456-compute@developer.gserviceaccount.com',
           'sub': '123456-compute@developer.gserviceaccount.com',
           'aud': 'https://firestore.googleapis.com/',
           'iat': iat,
           'exp': exp}
additional_headers = {'kid': PRIVATE_KEY_ID_FROM_JSON}
signed_jwt = jwt.encode(payload, PRIVATE_KEY_FROM_JSON, headers=additional_headers,
                       algorithm='RS256')
서명된 JWT를 Bearer 토큰으로 사용하여 API를 호출합니다.
GET /v1/projects/abc/databases/123/indexes HTTP/1.1
Authorization: Bearer SIGNED_JWT
Host: firestore.googleapis.com
계정 간 보안 구현
사용자 계정을 보호하기 위해 취해야 하는 추가 단계는 Google의 교차 계정 보호 서비스를 활용하여 교차 계정 보호를 구현하는 것입니다. 이 서비스를 사용하면 사용자 계정의 주요 변경사항에 관한 정보를 애플리케이션에 제공하는 보안 이벤트 알림을 구독할 수 있습니다. 그런 다음 이 정보를 사용하여 이벤트에 어떻게 대응할지 결정한 후 조치를 취할 수 있습니다.
Google의 교차 계정 보호 서비스에서 앱으로 전송하는 이벤트 유형의 예는 다음과 같습니다.
https://schemas.openid.net/secevent/risc/event-type/sessions-revoked
https://schemas.openid.net/secevent/oauth/event-type/token-revoked
https://schemas.openid.net/secevent/risc/event-type/account-disabled
교차 계정 보호를 구현하는 방법과 사용 가능한 이벤트의 전체 목록은 교차 계정 보호로 사용자 계정 보호 페이지 [https://developers.google.com/identity/protocols/risc?hl=ko]를 참고하세요.
의견 보내기